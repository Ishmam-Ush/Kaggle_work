# Count negative numbers in a list
numbers = [1, -2, 3, -4, 5, -6, 7, -8]
def count_negatives(nums):
    negative = 0
    for num in nums:
        if num<0:
            negative= negative + 1
    return negative
print(count_negatives(numbers))  # This counts the number of negative numbers in the list and prints the result.

# Count negative numbers in a list using list comprehension
def count_negatives_comprehension(nums):
    return len([num for num in nums if num <0])
print(count_negatives_comprehension(numbers))  # This uses list comprehension to count the number of negative numbers in the list and prints the result.

# Different way of solbving the same problem
def count_negatives_alternative(nums):
    return sum([num < 0 for num in nums])
print(count_negatives_alternative(numbers)) ### whle printing why are we defining numbers instead of calling it nums as we have defined nums before not nums???

# Exercise 4 [ WHILE DOING PROBLEMS LIKE THIS IM HAVING ISSUES VISUALIZING HOW TO CREATE THE BOSY CODE LIKE LINE 35 WHILE IM DEFINING i INDEX , HOW DO I EFFICIENTLY VISUALIZE THE FLOW OF THE PROGRAMMING CODES , IS THERE ANY SOURCE TO PRACTICE FLOW CHARTS OR ALGORITHMS ???}
import random # importing the random module to generate random numbers
def play_slot_machine():
    """Simulate playing a slot machine. Returns a random payout (0, 0, 1,0,1,0,0,0,0,5,0,0,0,0,7,0,0,0,0,1,0,0,0,0,1,0,0,0,0,5,0,0,0,1)."""
    return random.choice([0, 0, 1,0,1,0,0,0,0,5,0,0,0,0,7,0,0,0,0,1,0,0,0,0,1,0,0,0,0,5,0,0,0,1])# This function simulates playing a slot machine by randomly selecting a payout from a predefined list of possible payouts.

def estimate_average_slot_payout(n_runs):
    """Run the slot machine n_runs times and return the average net profit per run.
    Example calls (note that return value is nondeterministic!):
    >>> estimate_average_slot_payout(1)
    -1
    >>> estimate_average_slot_payout(1)
    0.5
    """
    payouts = [play_slot_machine()-1 for i in range(n_runs)] # This creates a list of payouts by playing the slot machine n_runs times and subtracting 1 from each payout to account for the cost of playing.
    # The payouts are generated by the play_slot_machine function, which simulates the slot machine.
    return  sum(payouts) / n_runs # This calculates the average payout by summing all the payouts and dividing by the number of runs.
# Example usage of the slot machine simulation
print(estimate_average_slot_payout(1000))  # This runs the slot machine 1000 times and returns the average net profit per run.
